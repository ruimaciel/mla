/* Generated by re2c 0.13.5 on Fri Jan  6 08:57:51 2017 */
#ifndef MLA_PARSER_MATRIX_MARKET_HPP
#define MLA_PARSER_MATRIX_MARKET_HPP

#include <istream>
#include <cstring>	// memcpy
#include <stack>	// memcpy
#include <functional>	// std::function

#include <map>
#include <stack>

#include <mla/LAException.h++>

#include <mla/matrix/SparseDOK.h++>


namespace mla {


/**
 * A parser for the MatrixMarket file format
 */
class MatrixMarket
{
private:
	static const size_t buff_size = 64;
	char buffer[buff_size+1];
	char *cursor;
	char *start_marker;
	char *marker;
	char *limit;
	unsigned int current_line_number;

public:
	long integer_number;
	double real_number;

public:
	enum ReturnCode
	{
		ERROR_OK,
		ERROR_LEXER,
		ERROR_PARSER,
		ERROR_UNKNOWN
	};

	enum Symbol	// collection of terminal symbols (TS_) and non-terminal symbols (NTS_)
	{
		TS_UNKNOWN	= 0,	// nice round number to help debuging
		TS_COMMENT,	// '%'
		TS_STRING_MATRIX_MARKET, 	// 'MatrixMarket'
		TS_STRING_MATRIX,		// 'matrix'
		TS_STRING_COORDINATE,		// 'coordinate'
		TS_STRING_ARRAY,		// 'array'
		TS_STRING_REAL,			// 'real'
		TS_STRING_INTEGER,		// 'integer'
		TS_STRING_COMPLEX,		// 'complex'
		TS_STRING_PATTERN,		// 'pattern'
		TS_STRING_GENERAL,		// 'general'
		TS_STRING_SYMMETRIC,		// 'symmetric'
		TS_STRING_SKEW_SYMMETRIC,	// 'skew-symmetric'
		TS_STRING_HERMITIAN,		// 'Hermitian'
		TS_INTEGER_NUMBER,
		TS_REAL_NUMBER,
		TS_EOL,
		TS_EOF,

		NTS_START = 100,
		NTS_DEFINE_TYPE,
		NTS_DEFINE_MATRIX_TYPE,
		NTS_DEFINE_ARRAY_MATRIX_TYPE,
		NTS_DEFINE_COORDINATE_MATRIX_SCALAR_TYPE,
		NTS_DEFINE_COORDINATE_MATRIX_STRUCTURE_TYPE,

		NTS_DEFINE_REAL_ARRAY_MATRIX_STRUCTURE_TYPE,

		NTS_READ_REAL_COORDINATE_MATRIX,
		NTS_READ_INTEGER_COORDINATE_MATRIX,
		NTS_READ_COMPLEX_COORDINATE_MATRIX,

		NTS_PARSE_REAL_GENERAL_ARRAY_MATRIX,

		NTS_COORDINATE_MATRIX_HEADER,	// rows, columns, NNZ entries
		NTS_COORDINATE_MATRIX_HEADER_SET,	// resize matrix

		NTS_ARRAY_MATRIX_HEADER,	// rows, columns
		NTS_ARRAY_MATRIX_HEADER_SET,	// resize matrix

		NTS_GET_ROWS,
		NTS_GET_COLUMNS,
		NTS_GET_NNZ,

		NTS_GET_ROWS_SET,
		NTS_GET_COLUMNS_SET,
		NTS_GET_NNZ_SET,

		NTS_MATRIX_COORDINATE,
		NTS_MATRIX_COORDINATE_GET_I,
		NTS_MATRIX_COORDINATE_GET_I_SET,
		NTS_MATRIX_COORDINATE_GET_J,
		NTS_MATRIX_COORDINATE_GET_J_SET,

		NTS_REAL_COORDINATE_MATRIX_ELEMENT_LIST,
		NTS_REAL_COORDINATE_MATRIX_ELEMENT_SET,

		NTS_REAL_COORDINATE_MATRIX_ELEMENT,
		NTS_REAL_COORDINATE_MATRIX_ELEMENT_FOLLOW,

		NTS_REAL_MATRIX_ELEMENT,
		NTS_REAL_MATRIX_ELEMENT_INTEGER_SET,
		NTS_REAL_MATRIX_ELEMENT_SET,

		NTS_REAL_GENERAL_ARRAY_MATRIX_ELEMENT_LIST,
		NTS_REAL_GENERAL_ARRAY_MATRIX_ELEMENT,
		NTS_REAL_GENERAL_ARRAY_MATRIX_ELEMENT_FOLLOW,

		NTS_REAL_GENERAL_ARRAY_MATRIX_INTEGER_ELEMENT,
		NTS_REAL_GENERAL_ARRAY_MATRIX_REAL_ELEMENT,
	};

	enum ParserState
	{
		ST_ERROR = 0,
		ST_START,
		ST_DEFINE_MATRIX,
		ST_DEFINE_COORDINATE_MATRIX_TYPE,
		ST_DEFINE_ARRAY_MATRIX_TYPE,

		ST_DEFINE_COORDINATE_SCALAR_REAL,
		ST_DEFINE_COORDINATE_SCALAR_INTEGER,
		ST_DEFINE_COORDINATE_SCALAR_COMPLEX,

		ST_DEFINE_ARRAY_MATRIX_TYPE_REAL,
		ST_DEFINE_ARRAY_MATRIX_TYPE_INTEGER,
		ST_DEFINE_ARRAY_MATRIX_TYPE_COMPLEX,

		ST_DEFINE_REAL_GENERAL_ARRAY_MATRIX,
		ST_DEFINE_REAL_SYMMETRIC_ARRAY_MATRIX,
		ST_DEFINE_REAL_SKEW_SYMMETRIC_ARRAY_MATRIX,

		ST_DEFINE_MATRIX_STRUCTURE_GENERAL,
		ST_DEFINE_MATRIX_STRUCTURE_SYMMETRIC,
		ST_DEFINE_MATRIX_STRUCTURE_SKEW_SYMMETRIC,

		ST_PARSE_REAL_GENERAL_ARRAY_MATRIX,

		ST_GET_COORDINATE_MATRIX_HEADER,
		ST_GET_COORDINATE_MATRIX_HEADER_SET,
		
		ST_READ_REAL_COORDINATE_MATRIX,
		ST_READ_REAL_COORDINATE_MATRIX_COMMENT,
		ST_READ_INTEGER_COORDINATE_MATRIX,
		ST_READ_COMPLEX_COORDINATE_MATRIX,

		ST_GET_ROWS,
		ST_GET_COLUMNS,
		ST_GET_NNZ,

		ST_GET_ROWS_SET,
		ST_GET_COLUMNS_SET,
		ST_GET_NNZ_SET,

		ST_MATRIX_COORDINATE,
		ST_MATRIX_COORDINATE_GET_I,
		ST_MATRIX_COORDINATE_GET_I_SET,
		ST_MATRIX_COORDINATE_GET_J,
		ST_MATRIX_COORDINATE_GET_J_SET,

		ST_REAL_COORDINATE_MATRIX_ELEMENTS,
		ST_REAL_COORDINATE_MATRIX_ELEMENTS_SET,
		ST_REAL_COORDINATE_MATRIX_ELEMENT_FOLLOW,

		ST_REAL_COORDINATE_MATRIX_ELEMENT,
		ST_REAL_COORDINATE_MATRIX_ELEMENT_FOLLOW_1,
		ST_REAL_COORDINATE_MATRIX_ELEMENT_FOLLOW_2,
		ST_REAL_COORDINATE_MATRIX_ELEMENT_FOLLOW_3,

		ST_REAL_MATRIX_ELEMENT_INTEGER,
		ST_REAL_MATRIX_ELEMENT_INTEGER_SET,
		ST_REAL_MATRIX_ELEMENT_REAL,
		ST_REAL_MATRIX_ELEMENT_REAL_SET,
		
		ST_GET_ARRAY_MATRIX_HEADER,
		ST_GET_ARRAY_MATRIX_HEADER_SET,

		ST_REAL_GENERAL_ARRAY_MATRIX_REAL_ELEMENT_REAL,

		ST_REAL_GENERAL_ARRAY_MATRIX_ELEMENT_LIST_INTEGER,
		ST_REAL_GENERAL_ARRAY_MATRIX_ELEMENT_LIST_REAL
	};

	std::map<Symbol, std::map<Symbol, ParserState>>	table;
	std::stack<Symbol>	ss;	// symbol stack


private:
	/**
	 * state-dependent lexer
	 */
	enum Symbol (MatrixMarket::*m_current_lexer)(std::istream &) ;
	

public:
	MatrixMarket();


	/**
	 * parses the contents of input_stream to a matrix
	 */
	template<class MatrixStoragePolicy>
	ReturnCode parse(std::istream &input_stream, MatrixStoragePolicy &matrix);


	enum Symbol lexer(std::istream &input_stream);

	enum Symbol lexer_header(std::istream &input_stream);

	enum Symbol lexer_body(std::istream &input_stream);

	void fill_lexer_buffer(std::istream &input_stream, size_t n);

	void reset_lexer();

	void set_parser_table();
};




MatrixMarket::MatrixMarket()
{
	set_parser_table();
	reset_lexer();
	limit = buffer;
}


template<class MatrixStoragePolicy>
MatrixMarket::ReturnCode 
MatrixMarket::parse(std::istream &input_stream, MatrixStoragePolicy &matrix)
{
	// init the parser
	current_line_number = 0;
	m_current_lexer = &MatrixMarket::lexer_header;
	
	size_t rows, columns;
	//size_t nnz;	// at present, no matrix data type uses this.  therefore, ommitted
	size_t matrix_i;
	size_t matrix_j;

	double element_real;

	std::function<void (MatrixStoragePolicy &matrix, size_t i, size_t j, typename MatrixStoragePolicy::scalar_type value)> matrix_setter;	// used to set the elements of a matrix


	// set the initial symbol stack
	ss.push(TS_EOF);
	ss.push(NTS_START);

	Symbol symbol = lexer(input_stream);
	
	while(!ss.empty() )
	{
		if(symbol == ss.top())
		{
			ss.pop();
			symbol = lexer(input_stream);
			continue;
		}

		switch( table[ss.top()][symbol] )
		{
			case ST_ERROR:
				throw LAException("parser table defaulted");
				break;

			case ST_START:
				ss.pop();
				ss.push(NTS_DEFINE_TYPE);
				ss.push(TS_STRING_MATRIX_MARKET);
				ss.push(TS_COMMENT);
				ss.push(TS_COMMENT);
				break;

			case ST_DEFINE_MATRIX:
				ss.pop();
				ss.push(NTS_DEFINE_MATRIX_TYPE);
				ss.push(TS_STRING_MATRIX);
				break;


			case ST_DEFINE_COORDINATE_MATRIX_TYPE:
				ss.pop();
				ss.push(NTS_DEFINE_COORDINATE_MATRIX_SCALAR_TYPE);
				ss.push(TS_STRING_COORDINATE);
				break;

			
			case ST_DEFINE_ARRAY_MATRIX_TYPE:
				ss.pop();
				ss.push(NTS_DEFINE_ARRAY_MATRIX_TYPE);
				ss.push(TS_STRING_ARRAY);
				break;


			case ST_DEFINE_COORDINATE_SCALAR_REAL:
				ss.pop();
				ss.push(NTS_READ_REAL_COORDINATE_MATRIX);
				ss.push(TS_EOL);
				ss.push(NTS_DEFINE_COORDINATE_MATRIX_STRUCTURE_TYPE);
				ss.push(TS_STRING_REAL);
				break;

			case ST_DEFINE_COORDINATE_SCALAR_INTEGER:
				ss.pop();
				throw LAException("ST_DEFINE_COORDINATE_SCALAR_INTEGER: not implemented yet");
				ss.push(NTS_READ_INTEGER_COORDINATE_MATRIX);
				ss.push(TS_EOL);
				ss.push(NTS_DEFINE_COORDINATE_MATRIX_STRUCTURE_TYPE);
				ss.push(TS_STRING_INTEGER);
				break;

			case ST_DEFINE_COORDINATE_SCALAR_COMPLEX:
				ss.pop();
				throw LAException("ST_DEFINE_COORDINATE_SCALAR_COMPLEX: not implemented yet");
				ss.push(NTS_READ_COMPLEX_COORDINATE_MATRIX);
				ss.push(TS_EOL);
				ss.push(NTS_DEFINE_COORDINATE_MATRIX_STRUCTURE_TYPE);
				ss.push(TS_STRING_COMPLEX);
				break;
			

			case ST_DEFINE_ARRAY_MATRIX_TYPE_REAL:
				ss.pop();
				ss.push(NTS_PARSE_REAL_GENERAL_ARRAY_MATRIX);
				break;


			case ST_DEFINE_ARRAY_MATRIX_TYPE_INTEGER:
				ss.pop();
				throw LAException("ST_DEFINE_ARRAY_MATRIX_TYPE_INTEGER: not implemented yet");
				break;


			case ST_DEFINE_ARRAY_MATRIX_TYPE_COMPLEX:
				ss.pop();
				throw LAException("ST_DEFINE_ARRAY_MATRIX_TYPE_COMPLEX: not implemented yet");
				break;


			case ST_DEFINE_REAL_GENERAL_ARRAY_MATRIX:
				//TODO working on this
				ss.pop();
				ss.push(NTS_PARSE_REAL_GENERAL_ARRAY_MATRIX);
				ss.push(TS_EOL);
				ss.push(TS_STRING_GENERAL);
				throw LAException("ST_DEFINE_REAL_GENERAL_ARRAY_MATRIX: not implemented yet");
				break;


			case ST_DEFINE_MATRIX_STRUCTURE_GENERAL:
				ss.pop();
				ss.push(TS_STRING_GENERAL);
				matrix_setter = [](MatrixStoragePolicy &matrix, size_t i, size_t j, typename MatrixStoragePolicy::scalar_type value)
				{ 
					matrix(i-1,j-1) = value; 
				};
				break;


			case ST_DEFINE_MATRIX_STRUCTURE_SYMMETRIC:
				ss.pop();
				ss.push(TS_STRING_SYMMETRIC);
				matrix_setter = [](MatrixStoragePolicy &matrix, size_t i, size_t j, typename MatrixStoragePolicy::scalar_type value)
				{ 
					matrix(i-1,j-1) = value; 
					matrix(j-1,i-1) = value;
				};
				break;

			case ST_DEFINE_MATRIX_STRUCTURE_SKEW_SYMMETRIC:
				ss.pop();
				ss.push(TS_STRING_SKEW_SYMMETRIC);
				matrix_setter = [](MatrixStoragePolicy &matrix, size_t i, size_t j, typename MatrixStoragePolicy::scalar_type value)
				{ 
					if(i!=j)
					{
						matrix(i-1,j-1) = value; 
						matrix(j-1,i-1) = -value;
					}
				};
				break;

			case ST_READ_REAL_COORDINATE_MATRIX:
				ss.pop();
				ss.push(NTS_REAL_COORDINATE_MATRIX_ELEMENT_LIST);
				ss.push(NTS_COORDINATE_MATRIX_HEADER);
				break;

			case ST_READ_REAL_COORDINATE_MATRIX_COMMENT:
				ss.pop();
				ss.push(NTS_READ_REAL_COORDINATE_MATRIX);
				ss.push(TS_EOL);
				ss.push(TS_COMMENT);
				break;

			case ST_READ_INTEGER_COORDINATE_MATRIX:
				throw LAException("needs to implement support for integer coordinate matrix");
				break;


			case ST_READ_COMPLEX_COORDINATE_MATRIX:
				throw LAException("needs to implement support for complex coordinate matrix");
				break;


			case ST_GET_COORDINATE_MATRIX_HEADER:
				// parses <row> <column> <nnr> <eol>
				ss.pop();
				ss.push(TS_EOL);
				ss.push(NTS_COORDINATE_MATRIX_HEADER_SET);
				ss.push(NTS_GET_NNZ);
				ss.push(NTS_GET_COLUMNS);
				ss.push(NTS_GET_ROWS);
				break;

			case ST_GET_COORDINATE_MATRIX_HEADER_SET:
				// resizes matrix
				ss.pop();
				matrix.resize(rows, columns);
				break;

			case ST_GET_ROWS:
				ss.pop();
				ss.push(TS_INTEGER_NUMBER);
				ss.push(NTS_GET_ROWS_SET);
				break;

			case ST_GET_ROWS_SET:
				ss.pop();
				rows = integer_number;
				break;

			case ST_GET_COLUMNS:
				ss.pop();
				ss.push(TS_INTEGER_NUMBER);
				ss.push(NTS_GET_COLUMNS_SET);
				break;

			case ST_GET_COLUMNS_SET:
				ss.pop();
				columns = integer_number;
				break;

			case ST_GET_NNZ:
				ss.pop();
				ss.push(TS_INTEGER_NUMBER);
				ss.push(NTS_GET_NNZ_SET);
				break;

			case ST_GET_NNZ_SET:
				ss.pop();
				//nnz = integer_number;
				break;

			case ST_MATRIX_COORDINATE:
				ss.pop();	
				ss.push(NTS_MATRIX_COORDINATE_GET_J);
				ss.push(NTS_MATRIX_COORDINATE_GET_I);
				break;


			case ST_MATRIX_COORDINATE_GET_I:
				ss.pop();	
				ss.push(TS_INTEGER_NUMBER);
				ss.push(NTS_MATRIX_COORDINATE_GET_I_SET);
				break;


			case ST_MATRIX_COORDINATE_GET_I_SET:
				ss.pop();	
				matrix_i = integer_number;
				break;


			case ST_MATRIX_COORDINATE_GET_J:
				ss.pop();	
				ss.push(TS_INTEGER_NUMBER);
				ss.push(NTS_MATRIX_COORDINATE_GET_J_SET);
				break;


			case ST_MATRIX_COORDINATE_GET_J_SET:
				ss.pop();	
				matrix_j = integer_number;
				break;

			case ST_REAL_COORDINATE_MATRIX_ELEMENTS:
				ss.pop();	
				ss.push(NTS_REAL_COORDINATE_MATRIX_ELEMENT_FOLLOW);
				ss.push(NTS_REAL_COORDINATE_MATRIX_ELEMENT);
				break;

			case ST_REAL_COORDINATE_MATRIX_ELEMENT:
				ss.pop();	
				ss.push(TS_EOL);
				ss.push(NTS_REAL_COORDINATE_MATRIX_ELEMENT_SET);
				ss.push(NTS_REAL_MATRIX_ELEMENT);
				ss.push(NTS_MATRIX_COORDINATE);
				break;

			case ST_REAL_COORDINATE_MATRIX_ELEMENT_FOLLOW_1:
				ss.pop();	
				ss.push(NTS_REAL_COORDINATE_MATRIX_ELEMENT_LIST);
				break;

			case ST_REAL_COORDINATE_MATRIX_ELEMENT_FOLLOW_2:
				ss.pop();	
				ss.push(NTS_REAL_COORDINATE_MATRIX_ELEMENT_FOLLOW);
				ss.push(TS_EOL);
				break;

			case ST_REAL_COORDINATE_MATRIX_ELEMENT_FOLLOW_3:
				ss.pop();	
				break;

			case ST_REAL_COORDINATE_MATRIX_ELEMENTS_SET:
				//TODO check if this state should be removed
				ss.pop();	
				element_real = real_number;
				matrix_setter(matrix, matrix_i, matrix_j, (typename MatrixStoragePolicy::scalar_type)element_real);
				break;

			case ST_REAL_MATRIX_ELEMENT_INTEGER:
				ss.pop();	
				ss.push(NTS_REAL_MATRIX_ELEMENT_SET);
				ss.push(NTS_REAL_MATRIX_ELEMENT_INTEGER_SET);	// used to convert integer to real
				ss.push(TS_INTEGER_NUMBER);
				break;

			case ST_REAL_MATRIX_ELEMENT_INTEGER_SET:
				ss.pop();	
				real_number = (double)integer_number;
				break;

			case ST_REAL_MATRIX_ELEMENT_REAL:
				ss.pop();	
				ss.push(NTS_REAL_MATRIX_ELEMENT_SET);
				ss.push(TS_REAL_NUMBER);
				break;

			case ST_REAL_MATRIX_ELEMENT_REAL_SET:
				//TODO check if this state should be removed
				ss.pop();	
				element_real = real_number;
				matrix_setter(matrix, matrix_i, matrix_j, (typename MatrixStoragePolicy::scalar_type)element_real);
				break;

			case ST_PARSE_REAL_GENERAL_ARRAY_MATRIX:
				ss.pop();
				ss.push(NTS_REAL_GENERAL_ARRAY_MATRIX_ELEMENT_LIST);
				ss.push(NTS_ARRAY_MATRIX_HEADER);
				break;

			case ST_GET_ARRAY_MATRIX_HEADER:
				// parses <row> <column> <eol>
				ss.pop();
				ss.push(TS_EOL);
				ss.push(NTS_ARRAY_MATRIX_HEADER_SET);
				ss.push(NTS_GET_COLUMNS);
				ss.push(NTS_GET_ROWS);
				break;

			case ST_GET_ARRAY_MATRIX_HEADER_SET:
				// resizes the array matrix
				ss.pop();
				matrix.resize(rows, columns);
				break;


			case ST_REAL_GENERAL_ARRAY_MATRIX_ELEMENT_LIST_INTEGER:
				ss.pop();
				ss.push(NTS_REAL_GENERAL_ARRAY_MATRIX_ELEMENT_FOLLOW);
				ss.push(NTS_REAL_GENERAL_ARRAY_MATRIX_INTEGER_ELEMENT);
				break;

			case ST_REAL_GENERAL_ARRAY_MATRIX_ELEMENT_LIST_REAL:
				ss.pop();
				ss.push(NTS_REAL_GENERAL_ARRAY_MATRIX_ELEMENT_FOLLOW);
				ss.push(NTS_REAL_GENERAL_ARRAY_MATRIX_REAL_ELEMENT);
				break;

				throw LAException("needs to implement support for complex coordinate matrix");

			default:
				throw LAException("unknown parser state");
		}
	}

	return ERROR_OK;
}


enum MatrixMarket::Symbol 
MatrixMarket::lexer(std::istream &input_stream)
{
	return (this->*m_current_lexer)(input_stream);
}


#define YYFILL(n) fill_lexer_buffer(input_stream, n)


enum MatrixMarket::Symbol 
MatrixMarket::lexer_header(std::istream &input_stream)
{
	if( cursor > limit )
	{
		return TS_EOF;
	}

start:
	start_marker = cursor;
	
{
	std::istream::char_type yych;

	YYFILL(14);
	yych = *cursor;
	switch (yych) {
	case 0x00:	goto yy19;
	case '\t':
	case '\v':
	case '\f':
	case '\r':
	case ' ':
	case 'h':	goto yy15;
	case '\n':	goto yy17;
	case '%':	goto yy2;
	case 'H':	goto yy14;
	case 'M':	goto yy4;
	case 'a':	goto yy8;
	case 'c':	goto yy7;
	case 'g':	goto yy12;
	case 'i':	goto yy10;
	case 'm':	goto yy6;
	case 'p':	goto yy11;
	case 'r':	goto yy9;
	case 's':	goto yy13;
	default:	goto yy21;
	}
yy2:
	++cursor;
	{	return TS_COMMENT;			}
yy4:
	yych = *(marker = ++cursor);
	switch (yych) {
	case 'a':	goto yy109;
	default:	goto yy5;
	}
yy5:
	{	return TS_UNKNOWN;			}
yy6:
	yych = *(marker = ++cursor);
	switch (yych) {
	case 'a':	goto yy103;
	default:	goto yy5;
	}
yy7:
	yych = *(marker = ++cursor);
	switch (yych) {
	case 'o':	goto yy87;
	default:	goto yy5;
	}
yy8:
	yych = *(marker = ++cursor);
	switch (yych) {
	case 'r':	goto yy82;
	default:	goto yy5;
	}
yy9:
	yych = *(marker = ++cursor);
	switch (yych) {
	case 'e':	goto yy78;
	default:	goto yy5;
	}
yy10:
	yych = *(marker = ++cursor);
	switch (yych) {
	case 'n':	goto yy71;
	default:	goto yy5;
	}
yy11:
	yych = *(marker = ++cursor);
	switch (yych) {
	case 'a':	goto yy64;
	default:	goto yy5;
	}
yy12:
	yych = *(marker = ++cursor);
	switch (yych) {
	case 'e':	goto yy57;
	default:	goto yy5;
	}
yy13:
	yych = *(marker = ++cursor);
	switch (yych) {
	case 'k':	goto yy34;
	case 'y':	goto yy35;
	default:	goto yy5;
	}
yy14:
	yych = *(marker = ++cursor);
	switch (yych) {
	case 'e':	goto yy24;
	default:	goto yy5;
	}
yy15:
	++cursor;
	yych = *cursor;
	goto yy23;
yy16:
	{	goto start;		}
yy17:
	++cursor;
	{	
					m_current_lexer = &MatrixMarket::lexer_body; 
					current_line_number++;
					return TS_EOL;			
				}
yy19:
	++cursor;
	{	return TS_EOF;			}
yy21:
	yych = *++cursor;
	goto yy5;
yy22:
	++cursor;
	YYFILL(1);
	yych = *cursor;
yy23:
	switch (yych) {
	case '\t':
	case '\v':
	case '\f':
	case '\r':
	case ' ':
	case 'h':	goto yy22;
	default:	goto yy16;
	}
yy24:
	yych = *++cursor;
	switch (yych) {
	case 'r':	goto yy26;
	default:	goto yy25;
	}
yy25:
	cursor = marker;
	goto yy5;
yy26:
	yych = *++cursor;
	switch (yych) {
	case 'm':	goto yy27;
	default:	goto yy25;
	}
yy27:
	yych = *++cursor;
	switch (yych) {
	case 'i':	goto yy28;
	default:	goto yy25;
	}
yy28:
	yych = *++cursor;
	switch (yych) {
	case 't':	goto yy29;
	default:	goto yy25;
	}
yy29:
	yych = *++cursor;
	switch (yych) {
	case 'i':	goto yy30;
	default:	goto yy25;
	}
yy30:
	yych = *++cursor;
	switch (yych) {
	case 'a':	goto yy31;
	default:	goto yy25;
	}
yy31:
	yych = *++cursor;
	switch (yych) {
	case 'n':	goto yy32;
	default:	goto yy25;
	}
yy32:
	++cursor;
	{	return TS_STRING_HERMITIAN;		}
yy34:
	yych = *++cursor;
	switch (yych) {
	case 'e':	goto yy44;
	default:	goto yy25;
	}
yy35:
	yych = *++cursor;
	switch (yych) {
	case 'm':	goto yy36;
	default:	goto yy25;
	}
yy36:
	yych = *++cursor;
	switch (yych) {
	case 'm':	goto yy37;
	default:	goto yy25;
	}
yy37:
	yych = *++cursor;
	switch (yych) {
	case 'e':	goto yy38;
	default:	goto yy25;
	}
yy38:
	yych = *++cursor;
	switch (yych) {
	case 't':	goto yy39;
	default:	goto yy25;
	}
yy39:
	yych = *++cursor;
	switch (yych) {
	case 'r':	goto yy40;
	default:	goto yy25;
	}
yy40:
	yych = *++cursor;
	switch (yych) {
	case 'i':	goto yy41;
	default:	goto yy25;
	}
yy41:
	yych = *++cursor;
	switch (yych) {
	case 'c':	goto yy42;
	default:	goto yy25;
	}
yy42:
	++cursor;
	{	return TS_STRING_SYMMETRIC;		}
yy44:
	yych = *++cursor;
	switch (yych) {
	case 'w':	goto yy45;
	default:	goto yy25;
	}
yy45:
	yych = *++cursor;
	switch (yych) {
	case '-':	goto yy46;
	default:	goto yy25;
	}
yy46:
	yych = *++cursor;
	switch (yych) {
	case 's':	goto yy47;
	default:	goto yy25;
	}
yy47:
	yych = *++cursor;
	switch (yych) {
	case 'y':	goto yy48;
	default:	goto yy25;
	}
yy48:
	yych = *++cursor;
	switch (yych) {
	case 'm':	goto yy49;
	default:	goto yy25;
	}
yy49:
	yych = *++cursor;
	switch (yych) {
	case 'm':	goto yy50;
	default:	goto yy25;
	}
yy50:
	yych = *++cursor;
	switch (yych) {
	case 'e':	goto yy51;
	default:	goto yy25;
	}
yy51:
	yych = *++cursor;
	switch (yych) {
	case 't':	goto yy52;
	default:	goto yy25;
	}
yy52:
	yych = *++cursor;
	switch (yych) {
	case 'r':	goto yy53;
	default:	goto yy25;
	}
yy53:
	yych = *++cursor;
	switch (yych) {
	case 'i':	goto yy54;
	default:	goto yy25;
	}
yy54:
	yych = *++cursor;
	switch (yych) {
	case 'c':	goto yy55;
	default:	goto yy25;
	}
yy55:
	++cursor;
	{	return TS_STRING_SKEW_SYMMETRIC;	}
yy57:
	yych = *++cursor;
	switch (yych) {
	case 'n':	goto yy58;
	default:	goto yy25;
	}
yy58:
	yych = *++cursor;
	switch (yych) {
	case 'e':	goto yy59;
	default:	goto yy25;
	}
yy59:
	yych = *++cursor;
	switch (yych) {
	case 'r':	goto yy60;
	default:	goto yy25;
	}
yy60:
	yych = *++cursor;
	switch (yych) {
	case 'a':	goto yy61;
	default:	goto yy25;
	}
yy61:
	yych = *++cursor;
	switch (yych) {
	case 'l':	goto yy62;
	default:	goto yy25;
	}
yy62:
	++cursor;
	{	return TS_STRING_GENERAL;		}
yy64:
	yych = *++cursor;
	switch (yych) {
	case 't':	goto yy65;
	default:	goto yy25;
	}
yy65:
	yych = *++cursor;
	switch (yych) {
	case 't':	goto yy66;
	default:	goto yy25;
	}
yy66:
	yych = *++cursor;
	switch (yych) {
	case 'e':	goto yy67;
	default:	goto yy25;
	}
yy67:
	yych = *++cursor;
	switch (yych) {
	case 'r':	goto yy68;
	default:	goto yy25;
	}
yy68:
	yych = *++cursor;
	switch (yych) {
	case 'n':	goto yy69;
	default:	goto yy25;
	}
yy69:
	++cursor;
	{	return TS_STRING_PATTERN;		}
yy71:
	yych = *++cursor;
	switch (yych) {
	case 't':	goto yy72;
	default:	goto yy25;
	}
yy72:
	yych = *++cursor;
	switch (yych) {
	case 'e':	goto yy73;
	default:	goto yy25;
	}
yy73:
	yych = *++cursor;
	switch (yych) {
	case 'g':	goto yy74;
	default:	goto yy25;
	}
yy74:
	yych = *++cursor;
	switch (yych) {
	case 'e':	goto yy75;
	default:	goto yy25;
	}
yy75:
	yych = *++cursor;
	switch (yych) {
	case 'r':	goto yy76;
	default:	goto yy25;
	}
yy76:
	++cursor;
	{	return TS_STRING_INTEGER;		}
yy78:
	yych = *++cursor;
	switch (yych) {
	case 'a':	goto yy79;
	default:	goto yy25;
	}
yy79:
	yych = *++cursor;
	switch (yych) {
	case 'l':	goto yy80;
	default:	goto yy25;
	}
yy80:
	++cursor;
	{	return TS_STRING_REAL;		}
yy82:
	yych = *++cursor;
	switch (yych) {
	case 'r':	goto yy83;
	default:	goto yy25;
	}
yy83:
	yych = *++cursor;
	switch (yych) {
	case 'a':	goto yy84;
	default:	goto yy25;
	}
yy84:
	yych = *++cursor;
	switch (yych) {
	case 'y':	goto yy85;
	default:	goto yy25;
	}
yy85:
	++cursor;
	{	return TS_STRING_ARRAY;		}
yy87:
	yych = *++cursor;
	switch (yych) {
	case 'm':	goto yy89;
	case 'o':	goto yy88;
	default:	goto yy25;
	}
yy88:
	yych = *++cursor;
	switch (yych) {
	case 'r':	goto yy95;
	default:	goto yy25;
	}
yy89:
	yych = *++cursor;
	switch (yych) {
	case 'p':	goto yy90;
	default:	goto yy25;
	}
yy90:
	yych = *++cursor;
	switch (yych) {
	case 'l':	goto yy91;
	default:	goto yy25;
	}
yy91:
	yych = *++cursor;
	switch (yych) {
	case 'e':	goto yy92;
	default:	goto yy25;
	}
yy92:
	yych = *++cursor;
	switch (yych) {
	case 'x':	goto yy93;
	default:	goto yy25;
	}
yy93:
	++cursor;
	{	return TS_STRING_COMPLEX;		}
yy95:
	yych = *++cursor;
	switch (yych) {
	case 'd':	goto yy96;
	default:	goto yy25;
	}
yy96:
	yych = *++cursor;
	switch (yych) {
	case 'i':	goto yy97;
	default:	goto yy25;
	}
yy97:
	yych = *++cursor;
	switch (yych) {
	case 'n':	goto yy98;
	default:	goto yy25;
	}
yy98:
	yych = *++cursor;
	switch (yych) {
	case 'a':	goto yy99;
	default:	goto yy25;
	}
yy99:
	yych = *++cursor;
	switch (yych) {
	case 't':	goto yy100;
	default:	goto yy25;
	}
yy100:
	yych = *++cursor;
	switch (yych) {
	case 'e':	goto yy101;
	default:	goto yy25;
	}
yy101:
	++cursor;
	{	return TS_STRING_COORDINATE;		}
yy103:
	yych = *++cursor;
	switch (yych) {
	case 't':	goto yy104;
	default:	goto yy25;
	}
yy104:
	yych = *++cursor;
	switch (yych) {
	case 'r':	goto yy105;
	default:	goto yy25;
	}
yy105:
	yych = *++cursor;
	switch (yych) {
	case 'i':	goto yy106;
	default:	goto yy25;
	}
yy106:
	yych = *++cursor;
	switch (yych) {
	case 'x':	goto yy107;
	default:	goto yy25;
	}
yy107:
	++cursor;
	{	return TS_STRING_MATRIX;		}
yy109:
	yych = *++cursor;
	switch (yych) {
	case 't':	goto yy110;
	default:	goto yy25;
	}
yy110:
	yych = *++cursor;
	switch (yych) {
	case 'r':	goto yy111;
	default:	goto yy25;
	}
yy111:
	yych = *++cursor;
	switch (yych) {
	case 'i':	goto yy112;
	default:	goto yy25;
	}
yy112:
	yych = *++cursor;
	switch (yych) {
	case 'x':	goto yy113;
	default:	goto yy25;
	}
yy113:
	yych = *++cursor;
	switch (yych) {
	case 'M':	goto yy114;
	default:	goto yy25;
	}
yy114:
	yych = *++cursor;
	switch (yych) {
	case 'a':	goto yy115;
	default:	goto yy25;
	}
yy115:
	yych = *++cursor;
	switch (yych) {
	case 'r':	goto yy116;
	default:	goto yy25;
	}
yy116:
	yych = *++cursor;
	switch (yych) {
	case 'k':	goto yy117;
	default:	goto yy25;
	}
yy117:
	yych = *++cursor;
	switch (yych) {
	case 'e':	goto yy118;
	default:	goto yy25;
	}
yy118:
	yych = *++cursor;
	switch (yych) {
	case 't':	goto yy119;
	default:	goto yy25;
	}
yy119:
	++cursor;
	{	return TS_STRING_MATRIX_MARKET;	}
}

}


enum MatrixMarket::Symbol 
MatrixMarket::lexer_body(std::istream &input_stream)
{
	if( cursor > limit )
	{
		return TS_EOF;
	}

start:
	start_marker = cursor;
	
{
	std::istream::char_type yych;
	unsigned int yyaccept = 0;
	YYFILL(5);
	yych = *cursor;
	switch (yych) {
	case 0x00:	goto yy129;
	case '\t':
	case '\v':
	case '\f':
	case '\r':
	case ' ':
	case 'h':	goto yy125;
	case '\n':	goto yy127;
	case '%':	goto yy123;
	case '-':	goto yy134;
	case '0':	goto yy131;
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy133;
	default:	goto yy136;
	}
yy123:
	++cursor;
	yych = *cursor;
	goto yy157;
yy124:
	{	return TS_COMMENT;	}
yy125:
	++cursor;
	yych = *cursor;
	goto yy155;
yy126:
	{	goto start;			}
yy127:
	++cursor;
	{	
					current_line_number++;
					return TS_EOL;		
				}
yy129:
	++cursor;
	{	return TS_EOF;		}
yy131:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	switch (yych) {
	case '.':	goto yy141;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy151;
	case 'E':
	case 'e':	goto yy143;
	default:	goto yy132;
	}
yy132:
	{	
					std::string number(start_marker, cursor-start_marker);
					integer_number = std::stol(number);
					return TS_INTEGER_NUMBER;	
				}
yy133:
	yyaccept = 0;
	yych = *(marker = ++cursor);
	goto yy150;
yy134:
	++cursor;
	switch ((yych = *cursor)) {
	case '0':	goto yy137;
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy139;
	default:	goto yy135;
	}
yy135:
	{	return TS_UNKNOWN;		}
yy136:
	yych = *++cursor;
	goto yy135;
yy137:
	yyaccept = 1;
	yych = *(marker = ++cursor);
	switch (yych) {
	case '.':	goto yy141;
	case 'E':
	case 'e':	goto yy143;
	default:	goto yy138;
	}
yy138:
	{	
					std::string number(start_marker, cursor-start_marker);
					real_number = std::stod(number);
					return TS_REAL_NUMBER;	
				}
yy139:
	yyaccept = 1;
	marker = ++cursor;
	YYFILL(3);
	yych = *cursor;
	switch (yych) {
	case '.':	goto yy141;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy139;
	case 'E':
	case 'e':	goto yy143;
	default:	goto yy138;
	}
yy141:
	yych = *++cursor;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy147;
	default:	goto yy142;
	}
yy142:
	cursor = marker;
	switch (yyaccept) {
	case 0: 	goto yy132;
	case 1: 	goto yy138;
	}
yy143:
	yych = *++cursor;
	switch (yych) {
	case '+':
	case '-':	goto yy144;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy145;
	default:	goto yy142;
	}
yy144:
	yych = *++cursor;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy145;
	default:	goto yy142;
	}
yy145:
	++cursor;
	YYFILL(1);
	yych = *cursor;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy145;
	default:	goto yy138;
	}
yy147:
	yyaccept = 1;
	marker = ++cursor;
	YYFILL(3);
	yych = *cursor;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy147;
	case 'E':
	case 'e':	goto yy143;
	default:	goto yy138;
	}
yy149:
	yyaccept = 0;
	marker = ++cursor;
	YYFILL(3);
	yych = *cursor;
yy150:
	switch (yych) {
	case '.':	goto yy141;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy149;
	case 'E':
	case 'e':	goto yy143;
	default:	goto yy132;
	}
yy151:
	++cursor;
	YYFILL(1);
	yych = *cursor;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy151;
	default:	goto yy153;
	}
yy153:
	{	return TS_UNKNOWN;		}
yy154:
	++cursor;
	YYFILL(1);
	yych = *cursor;
yy155:
	switch (yych) {
	case '\t':
	case '\v':
	case '\f':
	case '\r':
	case ' ':
	case 'h':	goto yy154;
	default:	goto yy126;
	}
yy156:
	++cursor;
	YYFILL(1);
	yych = *cursor;
yy157:
	switch (yych) {
	case 0x00:
	case '\n':	goto yy124;
	default:	goto yy156;
	}
}

}


void 
MatrixMarket::fill_lexer_buffer(std::istream &input_stream, size_t n)
{
	using namespace std;

	if(limit < cursor + n)
	{
		//FIXIT if comment length > buffer_size, this will fail
		memmove(buffer, start_marker, limit-start_marker+1);

		// reposition pointers
		size_t delta = start_marker-buffer;
		start_marker = buffer;
		cursor -= delta;
		marker -= delta;
		limit -= delta;

		// re-fill the rest of the buffer
		if( input_stream.good() )
		{
			size_t filled_buffer = limit - buffer;
			input_stream.read(limit,  buff_size - filled_buffer);

			size_t filled_count = input_stream.gcount();
			limit += filled_count;
			*limit = '\0';
		}

	}
} 


void 
MatrixMarket::reset_lexer()
{
	cursor = buffer;
	start_marker = buffer;
	marker = buffer;
	limit = &buffer[buff_size];
	memset(buffer,'\0', buff_size);
}


void 
MatrixMarket::set_parser_table()
{
	table[NTS_START][TS_COMMENT]	= ST_START;

	table[NTS_DEFINE_TYPE][TS_STRING_MATRIX]			= ST_DEFINE_MATRIX;

	table[NTS_DEFINE_MATRIX_TYPE][TS_STRING_COORDINATE]		= ST_DEFINE_COORDINATE_MATRIX_TYPE;
	table[NTS_DEFINE_MATRIX_TYPE][TS_STRING_ARRAY]			= ST_DEFINE_ARRAY_MATRIX_TYPE;

	table[NTS_DEFINE_COORDINATE_MATRIX_SCALAR_TYPE][TS_STRING_REAL]		= ST_DEFINE_COORDINATE_SCALAR_REAL;
	table[NTS_DEFINE_COORDINATE_MATRIX_SCALAR_TYPE][TS_STRING_INTEGER]	= ST_DEFINE_COORDINATE_SCALAR_INTEGER;
	table[NTS_DEFINE_COORDINATE_MATRIX_SCALAR_TYPE][TS_STRING_COMPLEX]	= ST_DEFINE_COORDINATE_SCALAR_COMPLEX;

	table[NTS_DEFINE_ARRAY_MATRIX_TYPE][TS_STRING_REAL]		= ST_DEFINE_ARRAY_MATRIX_TYPE_REAL;
	table[NTS_DEFINE_ARRAY_MATRIX_TYPE][TS_STRING_INTEGER]		= ST_DEFINE_ARRAY_MATRIX_TYPE_INTEGER;
	table[NTS_DEFINE_ARRAY_MATRIX_TYPE][TS_STRING_COMPLEX]		= ST_DEFINE_ARRAY_MATRIX_TYPE_COMPLEX;

	table[NTS_DEFINE_REAL_ARRAY_MATRIX_STRUCTURE_TYPE][TS_STRING_GENERAL]		= ST_DEFINE_REAL_GENERAL_ARRAY_MATRIX;
	/*
	table[NTS_DEFINE_REAL_ARRAY_MATRIX_STRUCTURE_TYPE][TS_STRING_SYMMETRIC]		= ST_DEFINE_REAL_SYMMETRIC_ARRAY_MATRIX;
	table[NTS_DEFINE_REAL_ARRAY_MATRIX_STRUCTURE_TYPE][TS_STRING_SKEW_SYMMETRIC]	= ST_DEFINE_REAL_SKEW_SYMMETRIC_ARRAY_MATRIX;
	*/

	table[NTS_PARSE_REAL_GENERAL_ARRAY_MATRIX][TS_INTEGER_NUMBER]		= ST_PARSE_REAL_GENERAL_ARRAY_MATRIX;

	table[NTS_DEFINE_COORDINATE_MATRIX_STRUCTURE_TYPE][TS_STRING_GENERAL]		= ST_DEFINE_MATRIX_STRUCTURE_GENERAL;
	table[NTS_DEFINE_COORDINATE_MATRIX_STRUCTURE_TYPE][TS_STRING_SYMMETRIC]		= ST_DEFINE_MATRIX_STRUCTURE_SYMMETRIC;
	table[NTS_DEFINE_COORDINATE_MATRIX_STRUCTURE_TYPE][TS_STRING_SKEW_SYMMETRIC]	= ST_DEFINE_MATRIX_STRUCTURE_SKEW_SYMMETRIC;

	table[NTS_READ_REAL_COORDINATE_MATRIX][TS_INTEGER_NUMBER]	= ST_READ_REAL_COORDINATE_MATRIX;
	table[NTS_READ_REAL_COORDINATE_MATRIX][TS_COMMENT]		= ST_READ_REAL_COORDINATE_MATRIX_COMMENT;

	// parse the coordinate format header
	table[NTS_COORDINATE_MATRIX_HEADER][TS_INTEGER_NUMBER]		= ST_GET_COORDINATE_MATRIX_HEADER;
	table[NTS_COORDINATE_MATRIX_HEADER_SET][TS_EOL]			= ST_GET_COORDINATE_MATRIX_HEADER_SET;

	table[NTS_GET_ROWS][TS_INTEGER_NUMBER]				= ST_GET_ROWS;
	table[NTS_GET_COLUMNS][TS_INTEGER_NUMBER]			= ST_GET_COLUMNS;
	table[NTS_GET_NNZ][TS_INTEGER_NUMBER]				= ST_GET_NNZ;

	table[NTS_GET_ROWS_SET][TS_INTEGER_NUMBER]			= ST_GET_ROWS_SET;
	table[NTS_GET_COLUMNS_SET][TS_INTEGER_NUMBER]			= ST_GET_COLUMNS_SET;
	table[NTS_GET_NNZ_SET][TS_INTEGER_NUMBER]			= ST_GET_NNZ_SET;

	table[NTS_MATRIX_COORDINATE][TS_INTEGER_NUMBER]			= ST_MATRIX_COORDINATE;

	table[NTS_MATRIX_COORDINATE_GET_I][TS_INTEGER_NUMBER]		= ST_MATRIX_COORDINATE_GET_I;
	table[NTS_MATRIX_COORDINATE_GET_J][TS_INTEGER_NUMBER]		= ST_MATRIX_COORDINATE_GET_J;

	table[NTS_MATRIX_COORDINATE_GET_I_SET][TS_INTEGER_NUMBER]	= ST_MATRIX_COORDINATE_GET_I_SET;
	table[NTS_MATRIX_COORDINATE_GET_I_SET][TS_REAL_NUMBER]		= ST_MATRIX_COORDINATE_GET_I_SET;

	table[NTS_MATRIX_COORDINATE_GET_J_SET][TS_INTEGER_NUMBER]	= ST_MATRIX_COORDINATE_GET_J_SET;
	table[NTS_MATRIX_COORDINATE_GET_J_SET][TS_REAL_NUMBER]		= ST_MATRIX_COORDINATE_GET_J_SET;

	// parse the element list for the real coordinate matrix format 
	table[NTS_REAL_COORDINATE_MATRIX_ELEMENT_LIST][TS_INTEGER_NUMBER]	= ST_REAL_COORDINATE_MATRIX_ELEMENTS;

	table[NTS_REAL_COORDINATE_MATRIX_ELEMENT][TS_INTEGER_NUMBER]		= ST_REAL_COORDINATE_MATRIX_ELEMENT;

	table[NTS_REAL_COORDINATE_MATRIX_ELEMENT_FOLLOW][TS_INTEGER_NUMBER]	= ST_REAL_COORDINATE_MATRIX_ELEMENT_FOLLOW_1;
	table[NTS_REAL_COORDINATE_MATRIX_ELEMENT_FOLLOW][TS_EOL]		= ST_REAL_COORDINATE_MATRIX_ELEMENT_FOLLOW_2;
	table[NTS_REAL_COORDINATE_MATRIX_ELEMENT_FOLLOW][TS_EOF]		= ST_REAL_COORDINATE_MATRIX_ELEMENT_FOLLOW_3;

	table[NTS_REAL_COORDINATE_MATRIX_ELEMENT_SET][TS_EOL]		= ST_REAL_COORDINATE_MATRIX_ELEMENTS_SET;

	table[NTS_REAL_MATRIX_ELEMENT][TS_INTEGER_NUMBER]		= ST_REAL_MATRIX_ELEMENT_INTEGER;
	table[NTS_REAL_MATRIX_ELEMENT][TS_REAL_NUMBER]			= ST_REAL_MATRIX_ELEMENT_REAL;

	// convert integer to real
	table[NTS_REAL_MATRIX_ELEMENT_INTEGER_SET][TS_EOL]		= ST_REAL_MATRIX_ELEMENT_INTEGER_SET;
	table[NTS_REAL_MATRIX_ELEMENT_SET][TS_EOL]			= ST_REAL_MATRIX_ELEMENT_REAL_SET;

	//TODO working on this
	table[NTS_ARRAY_MATRIX_HEADER][TS_INTEGER_NUMBER]		= ST_GET_ARRAY_MATRIX_HEADER;
	table[NTS_ARRAY_MATRIX_HEADER_SET][TS_EOL]			= ST_GET_ARRAY_MATRIX_HEADER_SET;

	table[NTS_REAL_GENERAL_ARRAY_MATRIX_ELEMENT_LIST][TS_INTEGER_NUMBER]	= ST_REAL_GENERAL_ARRAY_MATRIX_ELEMENT_LIST_INTEGER;
	table[NTS_REAL_GENERAL_ARRAY_MATRIX_ELEMENT_LIST][TS_REAL_NUMBER]	= ST_REAL_GENERAL_ARRAY_MATRIX_ELEMENT_LIST_REAL;

	table[NTS_REAL_GENERAL_ARRAY_MATRIX_REAL_ELEMENT][TS_REAL_NUMBER]	= ST_REAL_GENERAL_ARRAY_MATRIX_REAL_ELEMENT_REAL;
}


}	// namespace mla

#endif
